<?xml version="1.0"?>
<VTKFile type="ImageData" version="0.1" byte_order="LittleEndian" compressor="vtkZLibDataCompressor">
  <RD format_version="1">
  
    <description>
        SmoothLifeL, a parameter set of SmoothLife, by Stephan Rafler.
        &lt;a href=&quot;http://arxiv.org/abs/1111.1567&quot;&gt;(PDF)&lt;/a&gt;
        
        This version uses smooth time stepping. Anti-aliasing and a smooth transition
        function are used to enable the size of the kernel to be as small as possible.
        
        We don't see the same glider with smooth time stepping but there are lots
        of interesting things to find.
    </description>

    <rule type="kernel" name="SmoothLifeL">
    
      <kernel number_of_chemicals="1" block_size_x="1" block_size_y="1" block_size_z="1">
        // ---------------------------------------------
        // SmoothLifeL (smooth time stepping 2D)
        __constant float ra = 10.0f;         // outer radius
        __constant float rr = 3.0f;          // ratio of radii
        __constant float b1 = 0.257f;        // birth1
        __constant float b2 = 0.336f;        // birth2
        __constant float s1 = 0.365f;        // survival1
        __constant float s2 = 0.549f;        // survival2
        __constant float alpha_n = 0.028f;   // outer sigmoid
        __constant float alpha_m = 0.147f;   // inner sigmoid
        __constant float dt = 0.1f;          // timestep
        // ---------------------------------------------
        
        float sigma1(float x,float a,float alpha) 
        { 
            return 1.0f / ( 1.0f + exp( -(x-a)*4.0f/alpha ) );
        }
        
        float sigma2(float x,float a,float b,float alpha)
        {
            return sigma1(x,a,alpha) 
                * ( 1.0f-sigma1(x,b,alpha) );
        }
        
        float sigma_m(float x,float y,float m,float alpha)
        {
            return x * ( 1.0f-sigma1(m,0.5f,alpha) ) 
                + y * sigma1(m,0.5f,alpha);
        }
        
        // the transition function
        // (n = outer fullness, m = inner fullness)
        float s(float n,float m)
        {
            // (different to that for smoothglider)
            return sigma_m( sigma2(n,b1,b2,alpha_n), 
                sigma2(n,s1,s2,alpha_n), m, alpha_m);
        }
        
        float ramp_step(float x,float a,float ea)
        {
            return clamp((x-a)/ea + 0.5f,0.0f,1.0f);
        }

        __kernel void rd_compute(__global float* a_in,
                                 __global float* a_out) 
        {
            // inner radius:
            const float rb = ra/rr;
            // area of annulus:
            const float PI = 3.14159265358979f;
            const float AREA_OUTER = PI * (ra*ra - rb*rb);
            const float AREA_INNER = PI * rb * rb;
            
            const int x = get_global_id(0);
            const int y = get_global_id(1);
            const int z = get_global_id(2);
            const int X = get_global_size(0);
            const int Y = get_global_size(1);
            const int i_here = X*(Y*z + y) + x;
            
            // how full are the annulus and inner disk?
            float outf = 0.0f, inf = 0.0f;
            for(int dx=-ra; dx&lt;=ra; dx++)
            {
                for(int dy=-ra; dy&lt;=ra; dy++)
                {
                    float r = sqrt((float)(dx*dx + dy*dy));
                    int tx = (x+dx+X) &amp; (X-1); // wrap
                    int ty = (y+dy+Y) &amp; (Y-1); // wrap
                    float val = a_in[ X*(Y*z+ty)+tx ]; 
                    inf  += val * ramp_step(-r,-rb,1.0f);
                    outf += val * ramp_step(-r,-ra,1.0f) 
                                * ramp_step(r,rb,1.0f);
                }
            }
            // normalize the fullnesses by area
            outf /= AREA_OUTER;
            inf /= AREA_INNER;
            
            // smooth time stepping:
            a_out[i_here] = clamp( a_in[i_here] 
                + dt * (2.0f*s(outf,inf)-1.0f), 0.0f, 1.0f );
        }
      </kernel>
      
    </rule>

    <initial_pattern_generator apply_when_loading="true">
      <overlay chemical="a">
        <overwrite />
        <white_noise low="0" high="0.75" />
        <everywhere />
      </overlay>
    </initial_pattern_generator>
    
    <render_settings>
      <color_low r="0" g="0" b="1" />
      <color_high r="1" g="0.5" b="0" />
      <show_color_scale value="true" />
      <show_displacement_mapped_surface value="false" />
      <timesteps_per_render value="1" />
    </render_settings>
    
  </RD>
  
  <ImageData WholeExtent="0 255 0 255 0 0" Origin="0 0 0" Spacing="1 1 1">
  <Piece Extent="0 255 0 255 0 0">
    <PointData>
      <DataArray type="Float32" Name="a" format="binary" RangeMin="0" RangeMax="0">
        CAAAAACAAAAAAAAANAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA=eJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAE=
      </DataArray>
    </PointData>
    <CellData>
    </CellData>
  </Piece>
  </ImageData>
</VTKFile>
