<?xml version="1.0"?>
<VTKFile type="ImageData" version="0.1" byte_order="LittleEndian" compressor="vtkZLibDataCompressor">
  <RD format_version="4">
    <description>
      The advection equation: da/dt = -da/dx

      Here we are integrating with fourth-order Runge-Kutta, perhaps the most popular of the explicit
      integration methods.
      
      Each timestep is computed in four steps: a -> b,c -> d,e,f -> g,h,i,j -> a as follows:
      
      &lt;ol&gt;
      &lt;li&gt;The derivative k1 is computed from the current state, a.
      &lt;li&gt;A half-step forward in time is taken, using k1: c = a + (timestep/2)*k1
      &lt;li&gt;The previous state, a, is copied into b.
      &lt;li&gt;The derivative k2 is computed from state c.
      &lt;li&gt;A half-step forward in time from the start is taken again, using k2 this time: f = b + (timestep/2)*k2
      &lt;li&gt;The two previous states b and c are copied into d and e.
      &lt;li&gt;The derivative k3 is computed from state f.
      &lt;li&gt;A full step forward in time from the start is taken, using k3: j = d + timestep*k3
      &lt;li&gt;The three previous states d, e and f are copied into g, h and i.
      &lt;li&gt;The derivative k4 is computed from state j.
      &lt;li&gt;The new state is given by a = g + (timestep/6) * (k1 + 2*k2 + 2*k3 + k4)
      &lt;/ol&gt;
      
      In this implementation the operations above are pipelined, so there are actually four patterns being simulated, interleaved but 
      unconnected with each other. This requires ten channels in total to store the data needed. Results appear every fourth
      frame.
    </description>
    <rule name="Advection" type="kernel">
      <kernel number_of_chemicals="10" block_size_x="1" block_size_y="1" block_size_z="1">
__kernel void rd_compute(__global float *a_in,__global float *b_in,__global float *c_in,__global float *d_in,__global float *e_in,__global float *f_in,__global float *g_in,__global float *h_in,__global float *i_in,__global float *j_in,
                         __global float *a_out,__global float *b_out,__global float *c_out,__global float *d_out,__global float *e_out,__global float *f_out,__global float *g_out,__global float *h_out,__global float *i_out,__global float *j_out)
{
    const int index_x = get_global_id(0);
    const int index_y = get_global_id(1);
    const int index_z = get_global_id(2);
    const int X = get_global_size(0);
    const int Y = get_global_size(1);
    const int Z = get_global_size(2);
    const int index_here = X*(Y*index_z + index_y) + index_x;

    float a = a_in[index_here];
    float b = b_in[index_here];
    float c = c_in[index_here];
    float d = d_in[index_here];
    float e = e_in[index_here];
    float f = f_in[index_here];
    float g = g_in[index_here];
    float h = h_in[index_here];
    float i = i_in[index_here];
    float j = j_in[index_here];

    const int xm1 = (index_x-1+X) &amp; (X-1); // wrap (assumes X is a power of 2)
    const int xp1 = (index_x+1) &amp; (X-1);
    const int index_e =  X*(Y*index_z + index_y) + xp1; // East
    const int index_w =  X*(Y*index_z + index_y) + xm1; // West
    float a_e = a_in[index_e];
    float a_w = a_in[index_w];
    float c_e = c_in[index_e];
    float c_w = c_in[index_w];
    float f_e = f_in[index_e];
    float f_w = f_in[index_w];
    float j_e = j_in[index_e];
    float j_w = j_in[index_w];

    float dx = 0.1f; // grid spacing
    float timestep = 0.01f;
    float x_gradient_a = ( a_e - a_w ) / ( 2.0 * dx );
    float x_gradient_c = ( c_e - c_w ) / ( 2.0 * dx );
    float x_gradient_f = ( f_e - f_w ) / ( 2.0 * dx );
    float x_gradient_j = ( j_e - j_w ) / ( 2.0 * dx );
    float delta_a = -x_gradient_a;
    float delta_c = -x_gradient_c;
    float delta_f = -x_gradient_f;
    float delta_j = -x_gradient_j;
    float k1 = ( h - g ) / ( 0.5f * timestep );
    float k2 = ( i - g ) / ( 0.5f * timestep );
    float k3 = ( j - g ) / timestep;
    float k4 = delta_j;
    a_out[index_here] = g + timestep / 6.0f * ( k1 + 2.0f * k2 + 2.0f * k3 + k4 );
    b_out[index_here] = a;
    c_out[index_here] = a + 0.5f * timestep * delta_a;
    d_out[index_here] = b;
    e_out[index_here] = c;
    f_out[index_here] = b + 0.5f * timestep * delta_c;
    g_out[index_here] = d;
    h_out[index_here] = e;
    i_out[index_here] = f;
    j_out[index_here] = d + timestep * delta_f;
}
      </kernel>
      
    </rule>
    
    <initial_pattern_generator apply_when_loading="true">
      <overlay chemical="a"> <overwrite /> <gaussian height="1" sigma="0.05"> <point3D x="0.5" y="0.5" z="0.5" /> </gaussian> <everywhere /> </overlay>
    </initial_pattern_generator>
    
    <render_settings>
      <surface_color r="1" g="1" b="1">
        
      </surface_color>
      <color_low r="0" g="0" b="1">
        
      </color_low>
      <color_high r="1" g="0" b="0">
        
      </color_high>
      <show_color_scale value="true">
        
      </show_color_scale>
      <show_multiple_chemicals value="false">
        
      </show_multiple_chemicals>
      <active_chemical value="a">
        
      </active_chemical>
      <low value="0">
        
      </low>
      <high value="1">
        
      </high>
      <vertical_scale_1D value="30">
        
      </vertical_scale_1D>
      <vertical_scale_2D value="15">
        
      </vertical_scale_2D>
      <contour_level value="0.25">
        
      </contour_level>
      <use_wireframe value="false">
        
      </use_wireframe>
      <show_cell_edges value="false">
        
      </show_cell_edges>
      <show_bounding_box value="true">
        
      </show_bounding_box>
      <slice_3D value="true">
        
      </slice_3D>
      <slice_3D_axis value="z">
        
      </slice_3D_axis>
      <slice_3D_position value="0.5">
        
      </slice_3D_position>
      <show_displacement_mapped_surface value="true">
        
      </show_displacement_mapped_surface>
      <color_displacement_mapped_surface value="true">
        
      </color_displacement_mapped_surface>
      <use_image_interpolation value="true">
        
      </use_image_interpolation>
      <timesteps_per_render value="8">
        
      </timesteps_per_render>
      <show_phase_plot value="false">
        
      </show_phase_plot>
      <phase_plot_x_axis value="a">
        
      </phase_plot_x_axis>
      <phase_plot_y_axis value="b">
        
      </phase_plot_y_axis>
      <phase_plot_z_axis value="c">
        
      </phase_plot_z_axis>
      
    </render_settings>
    
  </RD>
  <ImageData WholeExtent="0 255 0 0 0 0" Origin="0 0 0" Spacing="1 1 1">
  <Piece Extent="0 255 0 0 0 0">
    <PointData>
      <DataArray type="Float32" Name="a" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="b" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="c" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="d" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="e" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="f" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="g" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="h" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="i" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
      <DataArray type="Float32" Name="j" format="binary" RangeMin="0" RangeMax="0">
        AQAAAACAAAAABAAAEQAAAA==eJxjYBgFo2AUjFQAAAQAAAE=
      </DataArray>
    </PointData>
    <CellData>
    </CellData>
  </Piece>
  </ImageData>
</VTKFile>
