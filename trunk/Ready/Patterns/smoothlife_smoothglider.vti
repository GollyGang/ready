<?xml version="1.0"?>
<VTKFile type="ImageData" version="0.1" byte_order="LittleEndian" compressor="vtkZLibDataCompressor">
  <RD format_version="1">
  
    <description>
        The smoothglider, a parameter set of SmoothLife, by Stephan Rafler.
        &lt;a href=&quot;http://arxiv.org/abs/1111.1567&quot;&gt;(PDF)&lt;/a&gt;
        
        SmoothLife was designed as a continuous version of Conway's Game of Life.
        The glider is capable of travelling in any direction, and is similar in
        appearance to the one in Larger-than-Life.
        
        This version uses discrete time stepping. Anti-aliasing and a smooth transition
        function are used to enable the size of the kernel to be as small as possible.
    </description>

    <rule type="kernel" name="SmoothLife">
    
      <kernel number_of_chemicals="1" block_size_x="1" block_size_y="1" block_size_z="1">
        // ---------------------------------------------
        // smoothglider (discrete time stepping 2D)
        __constant float ra = 12.0f;         // outer radius
        __constant float rr = 3.0f;          // ratio of radii
        __constant float b1 = 0.278f;        // birth1
        __constant float b2 = 0.365f;        // birth2
        __constant float s1 = 0.267f;        // survival1
        __constant float s2 = 0.445f;        // survival2
        __constant float alpha_n = 0.028f;   // sigmoid width for outer fullness
        __constant float alpha_m = 0.147f;   // sigmoid width for inner fullness
        // ---------------------------------------------
        
        float sigma1(float x,float a,float alpha) 
        { 
            return 1.0f / ( 1.0f + exp( -(x-a)*4.0f/alpha ) );
        }
        
        float sigma2(float x,float a,float b,float alpha)
        {
            return sigma1(x,a,alpha) 
                * ( 1.0f-sigma1(x,b,alpha) );
        }
        
        float sigma_m(float x,float y,float m,float alpha)
        {
            return x * ( 1.0f-sigma1(m,0.5f,alpha) ) 
                + y * sigma1(m,0.5f,alpha);
        }
        
        // the transition function
        // (n = outer fullness, m = inner fullness)
        float s(float n,float m)
        {
            return sigma2( n, sigma_m(b1,s1,m,alpha_m), 
                sigma_m(b2,s2,m,alpha_m), alpha_n );
        }
        
        float ramp_step(float x,float a,float ea)
        {
            return clamp((x-a)/ea + 0.5f,0.0f,1.0f);
        }

        __kernel void rd_compute(__global float* a_in,
                                 __global float* a_out) 
        {
            // inner radius:
            const float rb = ra/rr;
            // area of annulus:
            const float PI = 3.14159265358979f;
            const float AREA_OUTER = PI * (ra*ra - rb*rb);
            const float AREA_INNER = PI * rb * rb;
            
            const int x = get_global_id(0);
            const int y = get_global_id(1);
            const int z = get_global_id(2);
            const int X = get_global_size(0);
            const int Y = get_global_size(1);
            const int i_here = X*(Y*z + y) + x;
            
            // how full are the annulus and inner disk?
            float outf = 0.0f, inf = 0.0f;
            for(int dx=-ra; dx&lt;=ra; dx++)
            {
                for(int dy=-ra; dy&lt;=ra; dy++)
                {
                    float r = sqrt((float)(dx*dx + dy*dy));
                    //if(r &gt; ra+0.5f) continue; // outside
                    int tx = (x+dx+X) &amp; (X-1); // wrap
                    int ty = (y+dy+Y) &amp; (Y-1); // wrap
                    float val = a_in[ X*(Y*z+ty)+tx ]; 
                    inf  += val * ramp_step(-r,-rb,1.0f);
                    outf += val * ramp_step(-r,-ra,1.0f) 
                                * ramp_step(r,rb,1.0f);
                }
            }
            outf /= AREA_OUTER; // normalize by area
            inf /= AREA_INNER; // normalize by area
            
            a_out[i_here] = s(outf,inf); // discrete time step
        }
      </kernel>
      
    </rule>

    <initial_pattern_generator apply_when_loading="true">
      <overlay chemical="a">
        <overwrite />
        <white_noise low="0" high="0.75" /> <!-- very sensitive to this -->
        <everywhere />
      </overlay>
    </initial_pattern_generator>
    
    <render_settings>
      <color_low r="0" g="0" b="1" />
      <color_high r="1" g="0.5" b="0" />
      <show_color_scale value="true" />
      <show_displacement_mapped_surface value="false" />
      <timesteps_per_render value="1" />
    </render_settings>
    
  </RD>
  
  <ImageData WholeExtent="0 255 0 255 0 0" Origin="0 0 0" Spacing="1 1 1">
  <Piece Extent="0 255 0 255 0 0">
    <PointData>
      <DataArray type="Float32" Name="a" format="binary" RangeMin="0" RangeMax="0">
        CAAAAACAAAAAAAAANAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA=eJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAE=
      </DataArray>
    </PointData>
    <CellData>
    </CellData>
  </Piece>
  </ImageData>
</VTKFile>
