<?xml version="1.0"?>
<VTKFile type="ImageData" version="0.1" byte_order="LittleEndian" compressor="vtkZLibDataCompressor">
  <RD format_version="1">
  
    <description>
        Jonathan McCabe (2010) &quot;&lt;a href=&quot;http://www.jonathanmccabe.com/Cyclic_Symmetric_Multi-Scale_Turing_Patterns.pdf&quot;&gt;Cyclic Symmetric Multi-Scale Turing Patterns&lt;/a&gt;&quot;

        The model from the section 'Simple Turing Patterns'. Each point 'adds variation' - if it is 
        darker than the local average then it becomes darker still, if it is lighter then it becomes lighter
        still. The current variation is computed by finding the average within two radii around each location.
    </description>

    <rule type="kernel" name="McCabe">
    
      <kernel number_of_chemicals="1" block_size_x="1" block_size_y="1" block_size_z="1">

        #define NUM_RADII 2
        __constant float radii[ NUM_RADII ] = { 20.0f, 8.0f };

        __kernel void rd_compute(__global float* a_in,
                                 __global float* a_out) 
        {
            const int bx = get_global_id(0);
            const int by = get_global_id(1);
            const int BX = get_global_size(0);
            const int BY = get_global_size(1);
            const int i_here = BX*by + bx;
            
            float densities[ NUM_RADII ];
            float areas[ NUM_RADII ];
            float radii_squared[ NUM_RADII ];
            for( int i = 0; i &lt; NUM_RADII; ++i )
            {
                densities[ i ] = 0.0f;
                areas[ i ] = 0.0f;
                radii_squared[ i ] = radii[ i ] * radii[ i ];
            }

            // compute the density of every disk
            float val;
            float largest_radius = radii[ 0 ];
            for(int dy=-largest_radius; dy&lt;=largest_radius; dy++)
            {
                for(int dx=-largest_radius; dx&lt;=largest_radius; dx++)
                {
                    int tx = (bx+dx+BX) &amp; (BX-1); // wrap (for powers of 2 only)
                    int ty = (by+dy+BY) &amp; (BY-1);
                    val = a_in[ BX*ty + tx ]; 
                    for( int i = 0; i &lt; NUM_RADII; ++i )
                    {
                        float inside = step( dx*dx+dy*dy, radii_squared[ i ] );
                        densities[ i ] += val * inside;
                        areas[ i ] += inside;
                    }
                }
            }
            for( int i = 0; i &lt; NUM_RADII; ++i )
            {
                densities[ i ] /= areas[ i ];
            }
            
            // add variation (push this value at this location away from its local average)
            float density_difference = densities[ 1 ] - densities[ 0 ];
            float diff = 0.01f * sign( density_difference );
            a_out[i_here] = clamp( a_in[i_here] + diff, -1.0f, 1.0f );
        }
      </kernel>
      
    </rule>

    <initial_pattern_generator apply_when_loading="true">
      <overlay chemical="a">
        <overwrite />
        <white_noise low="-0.1" high="0.1" />
        <everywhere />
      </overlay>
    </initial_pattern_generator>
    
    <render_settings>
      <color_low r="0" g="0" b="0" />
      <color_high r="1" g="1" b="1" />
      <low value="-1" />
      <high value="1" />
      <show_color_scale value="false" />
      <show_displacement_mapped_surface value="false" />
      <timesteps_per_render value="1" />
    </render_settings>
    
  </RD>
  
  <ImageData WholeExtent="0 255 0 255 0 0" Origin="0 0 0" Spacing="1 1 1">
  <Piece Extent="0 255 0 255 0 0">
    <PointData>
      <DataArray type="Float32" Name="a" format="binary" RangeMin="0" RangeMax="0">
        CAAAAACAAAAAAAAANAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA=eJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAF4nO3BAQEAAACAkP6v7ggKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABiAAAABeJztwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYgAAAAXic7cEBAQAAAICQ/q/uCAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAE=
      </DataArray>
    </PointData>
    <CellData>
    </CellData>
  </Piece>
  </ImageData>
</VTKFile>
